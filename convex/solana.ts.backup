/**
 * Solana Smart Contract Integration for Convex Backend
 *
 * This module provides server-side functions to interact with the
 * domin8_prgm smart contract from Convex cron jobs and mutations.
 */

import { Connection, PublicKey, Keypair, Transaction, SystemProgram } from '@solana/web3.js';
import { Program, AnchorProvider, Wallet, BN } from '@coral-xyz/anchor';
import { internal } from './_generated/api';
import { internalMutation, internalAction } from './_generated/server';

// Environment variables (set in Convex dashboard)
const SOLANA_RPC_URL = process.env.SOLANA_RPC_URL || 'https://api.devnet.solana.com';
const PROGRAM_ID = new PublicKey(process.env.GAME_PROGRAM_ID || '8BH1JMeZCohtUKcfGGTqpYjpwxMowZBi6HrnAhc6eJFz');
const BACKEND_WALLET_SECRET = process.env.BACKEND_WALLET_SECRET; // [185,143,171,38,...]

// PDA Seeds
const GAME_CONFIG_SEED = 'game_config';
const GAME_COUNTER_SEED = 'game_counter';
const GAME_ROUND_SEED = 'game_round';
const VAULT_SEED = 'vault';

/**
 * Initialize Solana connection and backend wallet
 */
function initializeSolana() {
  if (!BACKEND_WALLET_SECRET) {
    throw new Error('BACKEND_WALLET_SECRET not configured');
  }

  const connection = new Connection(SOLANA_RPC_URL, 'confirmed');

  // Parse backend wallet keypair from environment
  const secretKey = JSON.parse(BACKEND_WALLET_SECRET);
  const backendKeypair = Keypair.fromSecretKey(new Uint8Array(secretKey));

  const wallet = new Wallet(backendKeypair);
  const provider = new AnchorProvider(connection, wallet, { commitment: 'confirmed' });

  return { connection, provider, backendWallet: backendKeypair };
}

/**
 * Derive PDAs
 */
function derivePDAs() {
  const [gameConfigPda] = PublicKey.findProgramAddressSync(
    [Buffer.from(GAME_CONFIG_SEED)],
    PROGRAM_ID
  );

  const [gameCounterPda] = PublicKey.findProgramAddressSync(
    [Buffer.from(GAME_COUNTER_SEED)],
    PROGRAM_ID
  );

  const [vaultPda] = PublicKey.findProgramAddressSync(
    [Buffer.from(VAULT_SEED)],
    PROGRAM_ID
  );

  return { gameConfigPda, gameCounterPda, vaultPda };
}

function deriveGameRoundPda(roundId: number) {
  const roundIdBuffer = Buffer.alloc(8);
  roundIdBuffer.writeUInt32LE(roundId, 0);

  const [gameRoundPda] = PublicKey.findProgramAddressSync(
    [Buffer.from(GAME_ROUND_SEED), roundIdBuffer],
    PROGRAM_ID
  );

  return gameRoundPda;
}

/**
 * Fetch current round ID from on-chain
 */
export const fetchCurrentRoundId = internalAction({
  args: {},
  handler: async (): Promise<number> => {
    const { connection } = initializeSolana();
    const { gameCounterPda } = derivePDAs();

    try {
      const accountInfo = await connection.getAccountInfo(gameCounterPda);

      if (!accountInfo) {
        console.log('Game counter not initialized');
        return 0;
      }

      // Parse current_round_id (u64 at offset 8)
      const roundId = Number(new BN(accountInfo.data.slice(8, 16), 'le'));

      return roundId;
    } catch (error) {
      console.error('Error fetching current round ID:', error);
      return 0;
    }
  },
});

/**
 * Fetch game round data from on-chain
 */
export const fetchGameRound = internalAction({
  args: {},
  handler: async (ctx) => {
    const { connection } = initializeSolana();

    try {
      // Get current round ID
      const roundId = await ctx.runAction(internal.solana.fetchCurrentRoundId);
      const gameRoundPda = deriveGameRoundPda(roundId);

      const accountInfo = await connection.getAccountInfo(gameRoundPda);

      if (!accountInfo) {
        return null;
      }

      const data = accountInfo.data;

      // Parse game round account (simplified - use Anchor IDL in production)
      // Discriminator (8) + round_id (8) + status (1) + timestamps (16) + bet_count (4) + total_pot (8) + ...
      const parsedRoundId = Number(new BN(data.slice(8, 16), 'le'));
      const status = data[16]; // 0=Idle, 1=Waiting, 2=AwaitingWinner, 3=Finished
      const startTimestamp = Number(new BN(data.slice(17, 25), 'le'));
      const endTimestamp = Number(new BN(data.slice(25, 33), 'le'));
      const betCount = data.readUInt32LE(33);
      const totalPot = Number(new BN(data.slice(37, 45), 'le'));

      const statusMap = ['idle', 'waiting', 'awaitingWinnerRandomness', 'finished'];

      return {
        roundId: parsedRoundId,
        status: statusMap[status],
        startTimestamp,
        endTimestamp,
        betCount,
        totalPot,
        pda: gameRoundPda.toString(),
      };
    } catch (error) {
      console.error('Error fetching game round:', error);
      return null;
    }
  },
});

/**
 * Close betting window (backend-triggered after timeout)
 */
export const closeBettingWindow = internalAction({
  args: {},
  handler: async (ctx) => {
    const { connection, provider, backendWallet } = initializeSolana();

    try {
      const roundId = await ctx.runAction(internal.solana.fetchCurrentRoundId);
      const gameRoundPda = deriveGameRoundPda(roundId);
      const { gameConfigPda, vaultPda } = derivePDAs();

      // Check if betting window should be closed
      const gameData = await ctx.runAction(internal.solana.fetchGameRound);

      if (!gameData || gameData.status !== 'waiting') {
        console.log('Game not in waiting status, skipping close');
        return null;
      }

      const now = Math.floor(Date.now() / 1000);
      if (now < gameData.endTimestamp) {
        console.log('Betting window still open');
        return null;
      }

      console.log('Closing betting window for round', roundId);

      // Build and send close_betting_window instruction
      // In production, use: await program.methods.closeBettingWindow().accounts({...}).rpc()

      // Placeholder - implement with Anchor program
      console.log('TODO: Send close_betting_window transaction');

      return {
        success: true,
        roundId,
        signature: 'placeholder_tx',
      };
    } catch (error) {
      console.error('Error closing betting window:', error);
      return null;
    }
  },
});

/**
 * Select winner and trigger payout (backend-triggered after VRF fulfillment)
 */
export const selectWinnerAndPayout = internalAction({
  args: {},
  handler: async (ctx) => {
    const { connection, provider, backendWallet } = initializeSolana();

    try {
      const roundId = await ctx.runAction(internal.solana.fetchCurrentRoundId);
      const gameRoundPda = deriveGameRoundPda(roundId);
      const { gameConfigPda, vaultPda } = derivePDAs();

      // Get game state
      const gameData = await ctx.runAction(internal.solana.fetchGameRound);

      if (!gameData || gameData.status !== 'awaitingWinnerRandomness') {
        console.log('Game not awaiting winner selection');
        return null;
      }

      console.log('Selecting winner for round', roundId);

      // Get VRF request account from game data
      // Check if VRF is fulfilled
      // Build and send select_winner_and_payout instruction

      // Placeholder - implement with Anchor program
      console.log('TODO: Send select_winner_and_payout transaction');

      return {
        success: true,
        roundId,
        signature: 'placeholder_tx',
      };
    } catch (error) {
      console.error('Error selecting winner:', error);
      return null;
    }
  },
});

/**
 * Monitor VRF fulfillment status
 */
export const checkVrfFulfillment = internalAction({
  args: {},
  handler: async (ctx) => {
    const { connection } = initializeSolana();

    try {
      const gameData = await ctx.runAction(internal.solana.fetchGameRound);

      if (!gameData || gameData.status !== 'awaitingWinnerRandomness') {
        return { fulfilled: false, reason: 'Not awaiting VRF' };
      }

      // Get VRF request account from game data
      // Parse game_round account to get vrf_request_pubkey

      // Check VRF fulfillment status
      // In production: const vrfAccount = await connection.getAccountInfo(vrfRequestPubkey);
      // Check fulfilled flag at offset 48

      console.log('Checking VRF fulfillment for round', gameData.roundId);

      return {
        fulfilled: false, // Placeholder
        reason: 'VRF check not implemented',
      };
    } catch (error) {
      console.error('Error checking VRF fulfillment:', error);
      return { fulfilled: false, reason: 'Error checking VRF' };
    }
  },
});

/**
 * Sync game state from blockchain to Convex database
 */
export const syncGameState = internalMutation({
  args: {},
  handler: async (ctx) => {
    try {
      const gameData = await ctx.runAction(internal.solana.fetchGameRound);

      if (!gameData) {
        console.log('No active game on-chain');
        return;
      }

      // Update or create game in Convex database
      const existingGame = await ctx.db
        .query('games')
        .filter((q) => q.eq(q.field('roundId'), gameData.roundId))
        .first();

      if (existingGame) {
        // Update existing game
        await ctx.db.patch(existingGame._id, {
          status: gameData.status,
          betCount: gameData.betCount,
          totalPot: gameData.totalPot,
          endTimestamp: gameData.endTimestamp,
          lastSynced: Date.now(),
        });
      } else {
        // Create new game record
        await ctx.db.insert('games', {
          roundId: gameData.roundId,
          status: gameData.status,
          startTimestamp: gameData.startTimestamp,
          endTimestamp: gameData.endTimestamp,
          betCount: gameData.betCount,
          totalPot: gameData.totalPot,
          gamePda: gameData.pda,
          lastSynced: Date.now(),
        });
      }

      console.log('Game state synced:', gameData);
    } catch (error) {
      console.error('Error syncing game state:', error);
    }
  },
});
