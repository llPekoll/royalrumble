// Solana integration layer for the Convex crank service
import * as anchor from "@coral-xyz/anchor";
import { Connection, PublicKey, Keypair, Transaction, sendAndConfirmTransaction } from "@solana/web3.js";
import { 
  GameConfig, 
  GameRound, 
  GameStatus, 
  DOMIN8_PROGRAM_ID, 
  PDA_SEEDS,
  TRANSACTION_TYPES,
  INSTRUCTION_NAMES 
} from "./types";

// Import the IDL type (this will be generated by Anchor)
import type { Domin8Prgm } from "../../target/types/domin8_prgm";
import IDL from "./domin8_prgm.json";

export class SolanaClient {
  private connection: Connection;
  private program: anchor.Program<Domin8Prgm>;
  private provider: anchor.AnchorProvider;
  private authority: Keypair;

  constructor(
    rpcEndpoint: string,
    authorityPrivateKey: string
  ) {
    // Initialize connection
    this.connection = new Connection(rpcEndpoint, "confirmed");
    
    // Create authority keypair from private key
    const privateKeyBytes = JSON.parse(authorityPrivateKey);
    this.authority = Keypair.fromSecretKey(new Uint8Array(privateKeyBytes));
    
    // Create provider
    this.provider = new anchor.AnchorProvider(
      this.connection,
      new anchor.Wallet(this.authority),
      { commitment: "confirmed" }
    );
    
    // Initialize program with real IDL
    this.program = new anchor.Program<Domin8Prgm>(
      IDL as Domin8Prgm,
      this.provider
    );
  }

  // Get PDAs for the game accounts
  private getPDAs() {
    const [gameConfig] = PublicKey.findProgramAddressSync(
      [PDA_SEEDS.GAME_CONFIG],
      DOMIN8_PROGRAM_ID
    );
    
    const [gameRound] = PublicKey.findProgramAddressSync(
      [PDA_SEEDS.GAME_ROUND],
      DOMIN8_PROGRAM_ID
    );
    
    const [vault] = PublicKey.findProgramAddressSync(
      [PDA_SEEDS.VAULT],
      DOMIN8_PROGRAM_ID
    );

    return { gameConfig, gameRound, vault };
  }

  // Get current game configuration
  async getGameConfig(): Promise<GameConfig> {
    const { gameConfig } = this.getPDAs();
    const account = await this.program.account.gameConfig.fetch(gameConfig);
    
    return {
      authority: account.authority,
      treasury: account.treasury,
      houseFeeBasisPoints: account.houseFeeBasisPoints,
      minBetLamports: account.minBetLamports.toNumber(),
      smallGameDurationConfig: {
        waitingPhaseDuration: account.smallGameDurationConfig.waitingPhaseDuration.toNumber(),
      },
      // ORAO VRF configuration
      vrfFeeLamports: account.vrfFeeLamports.toNumber(),
      vrfNetworkState: account.vrfNetworkState,
      vrfTreasury: account.vrfTreasury,
    };
  }

  // Get current game round state (simplified for small games MVP)
  async getGameRound(): Promise<GameRound> {
    const { gameRound } = this.getPDAs();
    const account = await this.program.account.gameRound.fetch(gameRound);
    
    // Convert status from Anchor enum to our enum (simplified for small games MVP)
    let status: GameStatus;
    if (account.status.idle) status = GameStatus.Idle;
    else if (account.status.waiting) status = GameStatus.Waiting;
    else if (account.status.awaitingWinnerRandomness) status = GameStatus.AwaitingWinnerRandomness;
    else if (account.status.finished) status = GameStatus.Finished;
    else throw new Error("Unknown game status");

    return {
      roundId: account.roundId.toNumber(),
      status,
      startTimestamp: account.startTimestamp.toNumber(),
      players: account.players.map(p => ({
        wallet: p.wallet,
        totalBet: p.totalBet.toNumber(),
        timestamp: p.timestamp.toNumber(),
      })),
      initialPot: account.initialPot.toNumber(),
      winner: account.winner,
      // ORAO VRF integration
      vrfRequestPubkey: account.vrfRequestPubkey,
      vrfSeed: Array.from(account.vrfSeed),
      randomnessFulfilled: account.randomnessFulfilled,
    };
  }

  // Get current Solana slot
  async getCurrentSlot(): Promise<number> {
    return await this.connection.getSlot("confirmed");
  }

  // UNIFIED INSTRUCTION: Progress game from Waiting directly to AwaitingWinnerRandomness with ORAO VRF
  async unifiedProgressToResolution(): Promise<string> {
    const { gameConfig, gameRound } = this.getPDAs();
    
    // Build VRF request PDA
    const vrfRequestPda = this.getVrfRequestPDA();
    
    const tx = await this.program.methods
      .unifiedProgressToResolution()
      .accounts({
        gameRound: gameRound,   // IDL shows this should be game_round but Anchor converts to camelCase
        config: gameConfig,
        crank: this.authority.publicKey,
        vrfProgram: new PublicKey("VRFzZoJdhFWL8rkvu87LpKM3RbcVezpMEc6X5GVDr7y"),
        networkState: await this.getOraoNetworkState(),
        treasury: await this.getOraoTreasury(),
        vrfRequest: vrfRequestPda,
        systemProgram: anchor.web3.SystemProgram.programId,
      } as any) // Temporary until TypeScript types are properly generated
      .rpc();
      
    return tx;
  }

  // UNIFIED INSTRUCTION: Resolve winner using ORAO VRF and immediately distribute winnings
  async unifiedResolveAndDistribute(vrfRequestPubkey: PublicKey): Promise<string> {
    const { gameConfig, gameRound, vault } = this.getPDAs();
    
    // Fetch current game round to get player accounts
    const gameRoundAccount = await this.program.account.gameRound.fetch(gameRound);
    
    // Get treasury from game config
    const gameConfigAccount = await this.program.account.gameConfig.fetch(gameConfig);
    
    // Prepare remaining accounts - all player accounts that could potentially win
    const remainingAccounts = gameRoundAccount.players.map((player: any) => ({
      pubkey: player.wallet,
      isWritable: true, // Players' accounts will receive funds if they win
      isSigner: false,  // Players are not signing this transaction
    }));
    
    const tx = await this.program.methods
      .unifiedResolveAndDistribute()
      .accounts({
        gameRound: gameRound,   // IDL shows this should be game_round but Anchor converts to camelCase
        config: gameConfig,
        vault,
        crank: this.authority.publicKey,
        vrfRequest: vrfRequestPubkey,
        treasury: gameConfigAccount.treasury,
        systemProgram: anchor.web3.SystemProgram.programId,
      } as any) // Temporary until TypeScript types are properly generated
      .remainingAccounts(remainingAccounts)
      .rpc();
      
    return tx;
  }

  // Check if ORAO VRF is fulfilled
  async checkVrfFulfillment(vrfRequestPubkey: PublicKey): Promise<boolean> {
    try {
      const vrfAccount = await this.connection.getAccountInfo(vrfRequestPubkey);
      if (!vrfAccount || vrfAccount.data.length < 49) {
        return false;
      }
      
      // Check fulfillment flag at offset 48
      return vrfAccount.data[48] !== 0;
    } catch (error) {
      console.error("Error checking VRF fulfillment:", error);
      return false;
    }
  }

  // Helper methods for ORAO VRF
  private getVrfRequestPDA(): PublicKey {
    const { gameRound } = this.getPDAs();
    return PublicKey.findProgramAddressSync(
      [Buffer.from("vrf_request"), gameRound.toBuffer()],
      DOMIN8_PROGRAM_ID
    )[0];
  }

  private async getOraoNetworkState(): Promise<PublicKey> {
    // Get from game config
    const gameConfig = await this.getGameConfig();
    return gameConfig.vrfNetworkState;
  }

  private async getOraoTreasury(): Promise<PublicKey> {
    // Get from game config
    const gameConfig = await this.getGameConfig();
    return gameConfig.vrfTreasury;
  }


  // Confirm transaction with retry logic
  async confirmTransaction(
    signature: string, 
    maxRetries: number = 3,
    timeoutMs: number = 30000
  ): Promise<boolean> {
    let retries = 0;
    
    while (retries < maxRetries) {
      try {
        const result = await this.connection.confirmTransaction(
          signature,
          "confirmed"
        );
        
        if (result.value.err) {
          console.error(`Transaction failed: ${signature}`, result.value.err);
          return false;
        }
        
        return true;
      } catch (error) {
        retries++;
        console.warn(`Transaction confirmation retry ${retries}/${maxRetries} for ${signature}:`, error);
        
        if (retries >= maxRetries) {
          console.error(`Transaction confirmation failed after ${maxRetries} retries: ${signature}`);
          return false;
        }
        
        // Wait before retry
        await new Promise(resolve => setTimeout(resolve, 2000));
      }
    }
    
    return false;
  }

  // Health check - test connection and authority
  async healthCheck(): Promise<{ healthy: boolean; message: string; slot?: number }> {
    try {
      // Test connection
      const slot = await this.getCurrentSlot();
      
      // Test authority balance
      const balance = await this.connection.getBalance(this.authority.publicKey);
      if (balance < 10_000_000) { // Less than 0.01 SOL
        return {
          healthy: false,
          message: `Authority balance too low: ${balance / 1e9} SOL`,
          slot
        };
      }
      
      // Test if game accounts exist
      const { gameConfig, gameRound } = this.getPDAs();
      await this.program.account.gameConfig.fetch(gameConfig);
      await this.program.account.gameRound.fetch(gameRound);
      
      return {
        healthy: true,
        message: "All systems healthy",
        slot
      };
    } catch (error) {
      return {
        healthy: false,
        message: `Health check failed: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }
}