// Solana integration layer for the Convex crank service
"use node";
import * as anchor from "@coral-xyz/anchor";
import { Connection, PublicKey, Keypair, Transaction, VersionedTransaction } from "@solana/web3.js";
import { GameConfig, GameRound, GameStatus, DOMIN8_PROGRAM_ID, PDA_SEEDS } from "./types";
import { Buffer } from "buffer";
import bs58 from "bs58";

// Import the IDL type (this will be generated by Anchor)
import type { Domin8Prgm } from "../../target/types/domin8_prgm";
import IDL from "./domin8_prgm.json";

// Simple NodeWallet implementation for server-side use
class NodeWallet implements anchor.Wallet {
  constructor(readonly payer: Keypair) {}

  async signTransaction<T extends Transaction | VersionedTransaction>(tx: T): Promise<T> {
    if (tx instanceof Transaction) {
      tx.partialSign(this.payer);
    } else {
      // VersionedTransaction needs different signing
      tx.sign([this.payer]);
    }
    return tx;
  }

  async signAllTransactions<T extends Transaction | VersionedTransaction>(txs: T[]): Promise<T[]> {
    return txs.map((tx) => {
      if (tx instanceof Transaction) {
        tx.partialSign(this.payer);
      } else {
        tx.sign([this.payer]);
      }
      return tx;
    });
  }

  get publicKey(): PublicKey {
    return this.payer.publicKey;
  }
}

export class SolanaClient {
  private connection: Connection;
  private program: anchor.Program<Domin8Prgm>;
  private provider: anchor.AnchorProvider;
  private authority: Keypair;

  constructor(rpcEndpoint: string, authorityPrivateKey: string) {
    // Initialize connection
    this.connection = new Connection(rpcEndpoint, "confirmed");

    // Create authority keypair from private key
    // Support both JSON array and Base58 formats
    let privateKeyBytes: Uint8Array;

    try {
      const trimmed = authorityPrivateKey.trim();

      if (trimmed.startsWith("[") && trimmed.endsWith("]")) {
        // JSON array format: "[1,2,3,...]"
        privateKeyBytes = new Uint8Array(JSON.parse(trimmed));
      } else {
        // Base58 format (standard Solana wallet export)
        privateKeyBytes = bs58.decode(trimmed);

        // Validate it's a valid Solana keypair (64 bytes)
        if (privateKeyBytes.length !== 64) {
          throw new Error(`Invalid key length: ${privateKeyBytes.length} bytes (expected 64)`);
        }
      }

      this.authority = Keypair.fromSecretKey(privateKeyBytes);
    } catch (error) {
      throw new Error(
        `Failed to parse CRANK_AUTHORITY_PRIVATE_KEY: ${error instanceof Error ? error.message : String(error)}\n` +
          `Supported formats: JSON array [1,2,3,...] or Base58 string (88 chars)\n` +
          `Received (first 50 chars): ${authorityPrivateKey.substring(0, 50)}...`
      );
    }

    // Create provider with NodeWallet
    this.provider = new anchor.AnchorProvider(this.connection, new NodeWallet(this.authority), {
      commitment: "confirmed",
    });

    // Initialize program with real IDL
    this.program = new anchor.Program<Domin8Prgm>(IDL as Domin8Prgm, this.provider);
  }

  // Get PDAs for the game accounts
  private getPDAs() {
    const [gameConfig] = PublicKey.findProgramAddressSync(
      [PDA_SEEDS.GAME_CONFIG],
      DOMIN8_PROGRAM_ID
    );

    const [gameRound] = PublicKey.findProgramAddressSync([PDA_SEEDS.GAME_ROUND], DOMIN8_PROGRAM_ID);

    const [vault] = PublicKey.findProgramAddressSync([PDA_SEEDS.VAULT], DOMIN8_PROGRAM_ID);

    return { gameConfig, gameRound, vault };
  }

  // Get current game configuration
  async getGameConfig(): Promise<GameConfig> {
    const { gameConfig } = this.getPDAs();
    const account = await this.program.account.gameConfig.fetch(gameConfig);

    return {
      authority: account.authority,
      treasury: account.treasury,
      houseFeeBasisPoints: account.houseFeeBasisPoints,
      minBetLamports: account.minBetLamports.toNumber(),
      smallGameDurationConfig: {
        waitingPhaseDuration: account.smallGameDurationConfig.waitingPhaseDuration.toNumber(),
      },
      // ORAO VRF configuration
      vrfFeeLamports: account.vrfFeeLamports.toNumber(),
      vrfNetworkState: account.vrfNetworkState,
      vrfTreasury: account.vrfTreasury,
    };
  }

  // Get current game round state (simplified for small games MVP)
  async getGameRound(): Promise<GameRound> {
    const { gameRound } = this.getPDAs();
    const account = await this.program.account.gameRound.fetch(gameRound);

    // Convert status from Anchor enum to our enum (simplified for small games MVP)
    let status: GameStatus;
    if (account.status.idle) status = GameStatus.Idle;
    else if (account.status.waiting) status = GameStatus.Waiting;
    else if (account.status.awaitingWinnerRandomness) status = GameStatus.AwaitingWinnerRandomness;
    else if (account.status.finished) status = GameStatus.Finished;
    else throw new Error("Unknown game status");

    return {
      roundId: account.roundId.toNumber(),
      status,
      startTimestamp: account.startTimestamp.toNumber(),
      players: account.players.map((p) => ({
        wallet: p.wallet,
        totalBet: p.totalBet.toNumber(),
        timestamp: p.timestamp.toNumber(),
      })),
      initialPot: account.initialPot.toNumber(),
      winner: account.winner,
      // ORAO VRF integration
      vrfRequestPubkey: account.vrfRequestPubkey,
      vrfSeed: Array.from(account.vrfSeed),
      randomnessFulfilled: account.randomnessFulfilled,
    };
  }

  // Get current Solana slot
  async getCurrentSlot(): Promise<number> {
    return await this.connection.getSlot("confirmed");
  }

  // UNIFIED INSTRUCTION: Progress game from Waiting directly to AwaitingWinnerRandomness with ORAO VRF
  async unifiedProgressToResolution(): Promise<string> {
    const { gameConfig, gameRound } = this.getPDAs();

    // Build VRF request PDA
    const vrfRequestPda = this.getVrfRequestPDA();

    const tx = await this.program.methods
      .unifiedProgressToResolution()
      .accounts({
        gameRound: gameRound, // IDL shows this should be game_round but Anchor converts to camelCase
        config: gameConfig,
        crank: this.authority.publicKey,
        vrfProgram: new PublicKey("VRFzZoJdhFWL8rkvu87LpKM3RbcVezpMEc6X5GVDr7y"),
        networkState: await this.getOraoNetworkState(),
        treasury: await this.getOraoTreasury(),
        vrfRequest: vrfRequestPda,
        systemProgram: anchor.web3.SystemProgram.programId,
      } as any) // Temporary until TypeScript types are properly generated
      .rpc();

    return tx;
  }

  // UNIFIED INSTRUCTION: Resolve winner using ORAO VRF and immediately distribute winnings
  async unifiedResolveAndDistribute(vrfRequestPubkey: PublicKey): Promise<string> {
    const { gameConfig, gameRound, vault } = this.getPDAs();

    // Fetch current game round to get player accounts
    const gameRoundAccount = await this.program.account.gameRound.fetch(gameRound);

    // Get treasury from game config
    const gameConfigAccount = await this.program.account.gameConfig.fetch(gameConfig);

    // Prepare remaining accounts - all player accounts that could potentially win
    const remainingAccounts = gameRoundAccount.players.map((player: any) => ({
      pubkey: player.wallet,
      isWritable: true, // Players' accounts will receive funds if they win
      isSigner: false, // Players are not signing this transaction
    }));

    const tx = await this.program.methods
      .unifiedResolveAndDistribute()
      .accounts({
        gameRound: gameRound, // IDL shows this should be game_round but Anchor converts to camelCase
        config: gameConfig,
        vault,
        crank: this.authority.publicKey,
        vrfRequest: vrfRequestPubkey,
        treasury: gameConfigAccount.treasury,
        systemProgram: anchor.web3.SystemProgram.programId,
      } as any) // Temporary until TypeScript types are properly generated
      .remainingAccounts(remainingAccounts)
      .rpc();

    return tx;
  }

  // Check if ORAO VRF is fulfilled
  async checkVrfFulfillment(vrfRequestPubkey: PublicKey): Promise<boolean> {
    try {
      const vrfAccount = await this.connection.getAccountInfo(vrfRequestPubkey);
      if (!vrfAccount || vrfAccount.data.length < 49) {
        return false;
      }

      // Check fulfillment flag at offset 48
      return vrfAccount.data[48] !== 0;
    } catch (error) {
      console.error("Error checking VRF fulfillment:", error);
      return false;
    }
  }

  // Helper methods for ORAO VRF
  private getVrfRequestPDA(): PublicKey {
    const { gameRound } = this.getPDAs();
    return PublicKey.findProgramAddressSync(
      [Buffer.from("vrf_request"), gameRound.toBuffer()],
      DOMIN8_PROGRAM_ID
    )[0];
  }

  private async getOraoNetworkState(): Promise<PublicKey> {
    // Get from game config
    const gameConfig = await this.getGameConfig();
    return gameConfig.vrfNetworkState;
  }

  private async getOraoTreasury(): Promise<PublicKey> {
    // Get from game config
    const gameConfig = await this.getGameConfig();
    return gameConfig.vrfTreasury;
  }

  // Confirm transaction with retry logic
  async confirmTransaction(signature: string, maxRetries: number = 3): Promise<boolean> {
    let retries = 0;

    while (retries < maxRetries) {
      try {
        const result = await this.connection.confirmTransaction(signature, "confirmed");

        if (result.value.err) {
          console.error(`Transaction failed: ${signature}`, result.value.err);
          return false;
        }

        return true;
      } catch (error) {
        retries++;
        console.warn(
          `Transaction confirmation retry ${retries}/${maxRetries} for ${signature}:`,
          error
        );

        if (retries >= maxRetries) {
          console.error(
            `Transaction confirmation failed after ${maxRetries} retries: ${signature}`
          );
          return false;
        }

        // Wait before retry
        await new Promise((resolve) => setTimeout(resolve, 2000));
      }
    }

    return false;
  }

  // Health check - test connection and authority
  async healthCheck(): Promise<{ healthy: boolean; message: string; slot?: number }> {
    try {
      // Test connection
      const slot = await this.getCurrentSlot();

      // Test authority balance
      const balance = await this.connection.getBalance(this.authority.publicKey);
      if (balance < 10_000_000) {
        // Less than 0.01 SOL
        return {
          healthy: false,
          message: `Authority balance too low: ${balance / 1e9} SOL`,
          slot,
        };
      }

      // Test if game accounts exist
      const { gameConfig, gameRound } = this.getPDAs();
      await this.program.account.gameConfig.fetch(gameConfig);
      await this.program.account.gameRound.fetch(gameRound);

      return {
        healthy: true,
        message: "All systems healthy",
        slot,
      };
    } catch (error) {
      return {
        healthy: false,
        message: `Health check failed: ${error instanceof Error ? error.message : String(error)}`,
      };
    }
  }
}
