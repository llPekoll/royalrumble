// Solana integration layer for the Convex crank service
"use node";
import * as anchor from "@coral-xyz/anchor";
import { Connection, PublicKey, Keypair, Transaction, VersionedTransaction } from "@solana/web3.js";
import { GameConfig, GameRound, GameStatus, DOMIN8_PROGRAM_ID, PDA_SEEDS } from "./types";
import { Buffer } from "buffer";
import bs58 from "bs58";

// Import the IDL type (this will be generated by Anchor)
import type { Domin8Prgm } from "../../target/types/domin8_prgm";
import IDL from "./domin8_prgm.json";

// Simple NodeWallet implementation for server-side use
class NodeWallet implements anchor.Wallet {
  constructor(readonly payer: Keypair) {}

  async signTransaction<T extends Transaction | VersionedTransaction>(tx: T): Promise<T> {
    if (tx instanceof Transaction) {
      tx.partialSign(this.payer);
    } else {
      // VersionedTransaction needs different signing
      tx.sign([this.payer]);
    }
    return tx;
  }

  async signAllTransactions<T extends Transaction | VersionedTransaction>(txs: T[]): Promise<T[]> {
    return txs.map((tx) => {
      if (tx instanceof Transaction) {
        tx.partialSign(this.payer);
      } else {
        tx.sign([this.payer]);
      }
      return tx;
    });
  }

  get publicKey(): PublicKey {
    return this.payer.publicKey;
  }
}

export class SolanaClient {
  private connection: Connection;
  private program: anchor.Program<Domin8Prgm>;
  private provider: anchor.AnchorProvider;
  private authority: Keypair;

  constructor(rpcEndpoint: string, authorityPrivateKey: string) {
    // Initialize connection
    this.connection = new Connection(rpcEndpoint, "confirmed");

    // Create authority keypair from private key
    // Support both JSON array and Base58 formats
    let privateKeyBytes: Uint8Array;

    try {
      const trimmed = authorityPrivateKey.trim();

      if (trimmed.startsWith("[") && trimmed.endsWith("]")) {
        // JSON array format: "[1,2,3,...]"
        privateKeyBytes = new Uint8Array(JSON.parse(trimmed));
      } else {
        // Base58 format (standard Solana wallet export)
        privateKeyBytes = bs58.decode(trimmed);

        // Validate it's a valid Solana keypair (64 bytes)
        if (privateKeyBytes.length !== 64) {
          throw new Error(`Invalid key length: ${privateKeyBytes.length} bytes (expected 64)`);
        }
      }

      this.authority = Keypair.fromSecretKey(privateKeyBytes);
    } catch (error) {
      throw new Error(
        `Failed to parse CRANK_AUTHORITY_PRIVATE_KEY: ${error instanceof Error ? error.message : String(error)}\n` +
          `Supported formats: JSON array [1,2,3,...] or Base58 string (88 chars)\n` +
          `Received (first 50 chars): ${authorityPrivateKey.substring(0, 50)}...`
      );
    }

    // Create provider with NodeWallet
    this.provider = new anchor.AnchorProvider(this.connection, new NodeWallet(this.authority), {
      commitment: "confirmed",
    });

    // Initialize program with real IDL
    this.program = new anchor.Program<Domin8Prgm>(IDL as Domin8Prgm, this.provider);
  }

  // Get PDAs for the game accounts
  private getPDAs(roundId?: number, betIndex?: number) {
    const [gameConfig] = PublicKey.findProgramAddressSync(
      [PDA_SEEDS.GAME_CONFIG],
      DOMIN8_PROGRAM_ID
    );

    const [gameCounter] = PublicKey.findProgramAddressSync(
      [PDA_SEEDS.GAME_COUNTER],
      DOMIN8_PROGRAM_ID
    );

    const [vault] = PublicKey.findProgramAddressSync([PDA_SEEDS.VAULT], DOMIN8_PROGRAM_ID);

    // Derive per-game PDA if roundId is provided
    let gameRound: PublicKey | undefined;
    if (roundId !== undefined) {
      const roundIdBuffer = Buffer.alloc(8);
      roundIdBuffer.writeBigUInt64LE(BigInt(roundId));
      [gameRound] = PublicKey.findProgramAddressSync(
        [PDA_SEEDS.GAME_ROUND, roundIdBuffer],
        DOMIN8_PROGRAM_ID
      );
    }

    // Derive bet entry PDA if both roundId and betIndex are provided
    let betEntry: PublicKey | undefined;
    if (roundId !== undefined && betIndex !== undefined) {
      const roundIdBuffer = Buffer.alloc(8);
      roundIdBuffer.writeBigUInt64LE(BigInt(roundId));
      const betIndexBuffer = Buffer.alloc(4);
      const dataView = new DataView(betIndexBuffer.buffer);
      dataView.setUint32(0, betIndex, true); // little-endian
      [betEntry] = PublicKey.findProgramAddressSync(
        [PDA_SEEDS.BET_ENTRY, roundIdBuffer, betIndexBuffer],
        DOMIN8_PROGRAM_ID
      );
    }

    return { gameConfig, gameCounter, gameRound, vault, betEntry };
  }

  // Get current round ID from GameCounter
  async getCurrentRoundId(): Promise<number> {
    const { gameCounter } = this.getPDAs();

    try {
      const account = await this.program.account.gameCounter.fetchNullable(gameCounter);

      if (!account) {
        console.warn("Game counter account doesn't exist yet");
        return 0;
      }

      return account.currentRoundId?.toNumber() ?? 0;
    } catch (error) {
      console.error("Error fetching game counter:", error);
      return 0;
    }
  }

  // Get current game configuration
  async getGameConfig(): Promise<GameConfig | null> {
    const { gameConfig } = this.getPDAs();

    try {
      const account = await this.program.account.gameConfig.fetchNullable(gameConfig);

      if (!account) {
        console.warn("Game config account doesn't exist yet");
        return null;
      }

      return {
        authority: account.authority?.toBase58() ?? "",
        treasury: account.treasury?.toBase58() ?? "",
        houseFeeBasisPoints: account.houseFeeBasisPoints ?? 0,
        minBetLamports: account.minBetLamports?.toNumber() ?? 0,
        smallGameDurationConfig: {
          waitingPhaseDuration:
            account.smallGameDurationConfig?.waitingPhaseDuration?.toNumber() ?? 0,
        },
        betsLocked: account.betsLocked ?? false,
      };
    } catch (error) {
      console.error("Error fetching game config:", error);
      return null;
    }
  }

  // Get current game round state (simplified for small games MVP)
  async getGameRound(): Promise<GameRound | null> {
    // First get the current round ID
    const currentRoundId = await this.getCurrentRoundId();
    console.log("---->Current round ID:", currentRoundId);

    // Derive the PDA for the current round
    const { gameRound } = this.getPDAs(currentRoundId);

    if (!gameRound) {
      throw new Error("Failed to derive game round PDA");
    }

    try {
      // Fetch account with null check
      const account = await this.program.account.gameRound.fetchNullable(gameRound);

      // If account doesn't exist or was closed, return null
      if (!account) {
        console.log(`Game round ${currentRoundId} account doesn't exist or was closed`);
        return null;
      }

      // Convert status from Anchor enum to our enum (simplified for small games MVP)
      let status: GameStatus;
      if (account.status?.waiting) status = GameStatus.Waiting;
      else if (account.status?.awaitingWinnerRandomness)
        status = GameStatus.AwaitingWinnerRandomness;
      else if (account.status?.finished) status = GameStatus.Finished;
      else {
        console.warn("Unknown game status:", account.status);
        return null;
      }

      console.log("Fetched game round account:", account);

      return {
        roundId: account.roundId?.toNumber() ?? 0,
        status,
        startTimestamp: account.startTimestamp?.toNumber() ?? 0,
        endTimestamp: account.endTimestamp?.toNumber() ?? 0,
        betCount: account.betCount ?? 0,
        betAmounts: Array.from(account.betAmounts || []).map(
          (amount: any) => amount?.toNumber() ?? 0
        ),
        totalPot: account.totalPot?.toNumber() ?? 0,
        winner: account.winner ? account.winner.toBase58() : null, // Convert PublicKey to string or null
        winningBetIndex: account.winningBetIndex ?? 0,
        // ORAO VRF integration
        vrfRequestPubkey: account.vrfRequestPubkey ? account.vrfRequestPubkey.toBase58() : null, // Convert PublicKey to string or null
        vrfSeed: Array.from(account.vrfSeed || []),
        randomnessFulfilled: account.randomnessFulfilled ?? false,
      };
    } catch (error) {
      // Game round account doesn't exist yet (no bets placed)
      console.log("No game round exists yet for round", currentRoundId);
      console.log("Error details:", error);
      return null;
    }
  }

  // Get current Solana slot
  async getCurrentSlot(): Promise<number> {
    return await this.connection.getSlot("confirmed");
  }

  // Close betting window and lock game for resolution
  // NEW: For single-player games, passes player wallet for automatic refund
  async closeBettingWindow(): Promise<string> {
    // Get current round ID to derive correct game PDA
    const currentRoundId = await this.getCurrentRoundId();
    const { gameConfig, gameCounter, gameRound, vault } = this.getPDAs(currentRoundId);

    if (!gameRound) {
      throw new Error("Failed to derive game round PDA");
    }

    // Fetch current game round to get bet count
    const gameRoundAccount = await this.program.account.gameRound.fetch(gameRound);
    const betCount = gameRoundAccount.betCount;

    // Fetch BetEntry PDAs for all bets (needed to count unique players)
    const remainingAccounts = [];
    const uniquePlayers = new Set<string>();

    for (let i = 0; i < betCount; i++) {
      const { betEntry } = this.getPDAs(currentRoundId, i);
      if (betEntry) {
        remainingAccounts.push({
          pubkey: betEntry,
          isWritable: false, // Read-only for validation
          isSigner: false,
        });

        // Track unique players for single-player detection
        try {
          const betEntryAccount = await this.program.account.betEntry.fetch(betEntry);
          uniquePlayers.add(betEntryAccount.wallet.toBase58());
        } catch (error) {
          console.error(`Failed to fetch bet entry ${i}:`, error);
        }
      }
    }

    // NEW: For single-player games, add the player's wallet for automatic refund
    if (uniquePlayers.size === 1) {
      const playerWallet = Array.from(uniquePlayers)[0];
      remainingAccounts.push({
        pubkey: new PublicKey(playerWallet),
        isWritable: true, // IMPORTANT: Must be writable for automatic transfer
        isSigner: false, // Crank signs, not the player
      });
      console.log(
        `Single-player game detected. Automatic refund will be attempted for player: ${playerWallet}`
      );
    } else {
      console.log(
        `Multi-player game with ${uniquePlayers.size} players. No automatic refund needed.`
      );
    }

    console.log(`Closing betting window for round ${currentRoundId} with ${betCount} bets`);

    const tx = await this.program.methods
      .closeBettingWindow()
      .accounts({
        counter: gameCounter,
        gameRound: gameRound,
        config: gameConfig,
        vault, // NOW required for auto-refund (was optional before)
        crank: this.authority.publicKey,
      } as any)
      .remainingAccounts(remainingAccounts)
      .rpc();

    return tx;
  }

  // Select winner using VRF and distribute payouts
  async selectWinnerAndPayout(vrfRequestPubkeyStr: string): Promise<string> {
    const vrfRequestPubkey = new PublicKey(vrfRequestPubkeyStr);

    // Get current round ID to derive correct game PDA
    const currentRoundId = await this.getCurrentRoundId();
    const { gameConfig, gameCounter, gameRound, vault } = this.getPDAs(currentRoundId);

    if (!gameRound) {
      throw new Error("Failed to derive game round PDA");
    }

    // Fetch current game round to get bet count
    const gameRoundAccount = await this.program.account.gameRound.fetch(gameRound);

    // Get treasury from game config
    const gameConfigAccount = await this.program.account.gameConfig.fetch(gameConfig);

    // Fetch BetEntry PDAs for all bets to get player wallet addresses
    const betCount = gameRoundAccount.betCount;
    const remainingAccounts = [];

    for (let i = 0; i < betCount; i++) {
      const { betEntry } = this.getPDAs(currentRoundId, i);
      if (betEntry) {
        try {
          const betEntryAccount = await this.program.account.betEntry.fetch(betEntry);
          remainingAccounts.push({
            pubkey: betEntryAccount.wallet,
            isWritable: true, // Player accounts will receive funds if they win
            isSigner: false, // Player accounts are not signing this transaction
          });
        } catch (error) {
          console.error(`Failed to fetch bet entry ${i}:`, error);
        }
      }
    }

    // Skip preflight because simulation doesn't understand PDA signing (invoke_signed)
    // The vault PDA will sign the transfer within the program
    const tx = await this.program.methods
      .selectWinnerAndPayout()
      .accounts({
        counter: gameCounter,
        gameRound: gameRound,
        config: gameConfig,
        vault,
        crank: this.authority.publicKey,
        vrfRequest: vrfRequestPubkey,
        treasury: gameConfigAccount.treasury,
        systemProgram: anchor.web3.SystemProgram.programId,
      } as any) // Temporary until TypeScript types are properly generated
      .remainingAccounts(remainingAccounts)
      .rpc({ skipPreflight: true });

    return tx;
  }

  // Check if ORAO VRF is fulfilled
  async checkVrfFulfillment(vrfRequestPubkeyStr: string | null): Promise<boolean> {
    if (!vrfRequestPubkeyStr) {
      return false; // No VRF request yet
    }

    try {
      const vrfRequestPubkey = new PublicKey(vrfRequestPubkeyStr);
      const vrfAccount = await this.connection.getAccountInfo(vrfRequestPubkey);
      if (!vrfAccount || vrfAccount.data.length < 49) {
        return false;
      }

      // Check fulfillment flag at offset 48
      return vrfAccount.data[48] !== 0;
    } catch (error) {
      console.error("Error checking VRF fulfillment:", error);
      return false;
    }
  }

  // Note: VRF helper methods removed - VRF is now handled directly by the smart contract
  // via ORAO VRF integration in create_game instruction

  // Confirm transaction with retry logic
  async confirmTransaction(signature: string, maxRetries: number = 3): Promise<boolean> {
    let retries = 0;

    while (retries < maxRetries) {
      try {
        const result = await this.connection.confirmTransaction(signature, "confirmed");

        if (result.value.err) {
          console.error(`Transaction failed: ${signature}`, result.value.err);
          return false;
        }

        return true;
      } catch (error) {
        retries++;
        console.warn(
          `Transaction confirmation retry ${retries}/${maxRetries} for ${signature}:`,
          error
        );

        if (retries >= maxRetries) {
          console.error(
            `Transaction confirmation failed after ${maxRetries} retries: ${signature}`
          );
          return false;
        }

        // Wait before retry
        await new Promise((resolve) => setTimeout(resolve, 2000));
      }
    }

    return false;
  }

  // Health check - test connection and authority
  async healthCheck(): Promise<{ healthy: boolean; message: string; slot?: number }> {
    try {
      // Test connection
      const slot = await this.getCurrentSlot();

      // Test authority balance
      const balance = await this.connection.getBalance(this.authority.publicKey);
      if (balance < 10_000_000) {
        // Less than 0.01 SOL
        return {
          healthy: false,
          message: `Authority balance too low: ${balance / 1e9} SOL`,
          slot,
        };
      }

      // Test if game accounts exist
      const { gameConfig, gameCounter } = this.getPDAs();
      await this.program.account.gameConfig.fetch(gameConfig);
      await this.program.account.gameCounter.fetch(gameCounter);

      // Note: We don't check gameRound here since it may not exist yet (no bets placed)

      return {
        healthy: true,
        message: "All systems healthy",
        slot,
      };
    } catch (error) {
      return {
        healthy: false,
        message: `Health check failed: ${error instanceof Error ? error.message : String(error)}`,
      };
    }
  }
}
