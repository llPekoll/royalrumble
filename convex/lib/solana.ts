// Solana integration layer for the Convex crank service
"use node";
import * as anchor from "@coral-xyz/anchor";
import { Connection, PublicKey, Keypair, Transaction, VersionedTransaction } from "@solana/web3.js";
import { GameConfig, GameRound, GameStatus, DOMIN8_PROGRAM_ID, PDA_SEEDS } from "./types";
import { Buffer } from "buffer";
import bs58 from "bs58";

// Import the IDL type (this will be generated by Anchor)
import type { Domin8Prgm } from "../../target/types/domin8_prgm";
import IDL from "./domin8_prgm.json";

// Simple NodeWallet implementation for server-side use
class NodeWallet implements anchor.Wallet {
  constructor(readonly payer: Keypair) {}

  async signTransaction<T extends Transaction | VersionedTransaction>(tx: T): Promise<T> {
    if (tx instanceof Transaction) {
      tx.partialSign(this.payer);
    } else {
      // VersionedTransaction needs different signing
      tx.sign([this.payer]);
    }
    return tx;
  }

  async signAllTransactions<T extends Transaction | VersionedTransaction>(txs: T[]): Promise<T[]> {
    return txs.map((tx) => {
      if (tx instanceof Transaction) {
        tx.partialSign(this.payer);
      } else {
        tx.sign([this.payer]);
      }
      return tx;
    });
  }

  get publicKey(): PublicKey {
    return this.payer.publicKey;
  }
}

export class SolanaClient {
  private connection: Connection;
  private program: anchor.Program<Domin8Prgm>;
  private provider: anchor.AnchorProvider;
  private authority: Keypair;

  constructor(rpcEndpoint: string, authorityPrivateKey: string) {
    // Initialize connection
    this.connection = new Connection(rpcEndpoint, "confirmed");

    // Create authority keypair from private key
    // Support both JSON array and Base58 formats
    let privateKeyBytes: Uint8Array;

    try {
      const trimmed = authorityPrivateKey.trim();

      if (trimmed.startsWith("[") && trimmed.endsWith("]")) {
        // JSON array format: "[1,2,3,...]"
        privateKeyBytes = new Uint8Array(JSON.parse(trimmed));
      } else {
        // Base58 format (standard Solana wallet export)
        privateKeyBytes = bs58.decode(trimmed);

        // Validate it's a valid Solana keypair (64 bytes)
        if (privateKeyBytes.length !== 64) {
          throw new Error(`Invalid key length: ${privateKeyBytes.length} bytes (expected 64)`);
        }
      }

      this.authority = Keypair.fromSecretKey(privateKeyBytes);
    } catch (error) {
      throw new Error(
        `Failed to parse CRANK_AUTHORITY_PRIVATE_KEY: ${error instanceof Error ? error.message : String(error)}\n` +
          `Supported formats: JSON array [1,2,3,...] or Base58 string (88 chars)\n` +
          `Received (first 50 chars): ${authorityPrivateKey.substring(0, 50)}...`
      );
    }

    // Create provider with NodeWallet
    this.provider = new anchor.AnchorProvider(this.connection, new NodeWallet(this.authority), {
      commitment: "confirmed",
    });

    // Initialize program with real IDL
    this.program = new anchor.Program<Domin8Prgm>(IDL as Domin8Prgm, this.provider);
  }

  // Get PDAs for the game accounts
  private getPDAs(roundId?: number) {
    const [gameConfig] = PublicKey.findProgramAddressSync(
      [PDA_SEEDS.GAME_CONFIG],
      DOMIN8_PROGRAM_ID
    );

    const [gameCounter] = PublicKey.findProgramAddressSync(
      [PDA_SEEDS.GAME_COUNTER],
      DOMIN8_PROGRAM_ID
    );

    const [vault] = PublicKey.findProgramAddressSync([PDA_SEEDS.VAULT], DOMIN8_PROGRAM_ID);

    // Derive per-game PDA if roundId is provided
    let gameRound: PublicKey | undefined;
    if (roundId !== undefined) {
      const roundIdBuffer = Buffer.alloc(8);
      roundIdBuffer.writeBigUInt64LE(BigInt(roundId));
      [gameRound] = PublicKey.findProgramAddressSync(
        [PDA_SEEDS.GAME_ROUND, roundIdBuffer],
        DOMIN8_PROGRAM_ID
      );
    }

    return { gameConfig, gameCounter, gameRound, vault };
  }

  // Get current round ID from GameCounter
  async getCurrentRoundId(): Promise<number> {
    const { gameCounter } = this.getPDAs();
    const account = await this.program.account.gameCounter.fetch(gameCounter);

    if (!account) {
      throw new Error("Failed to fetch game counter account");
    }

    return account.currentRoundId?.toNumber() ?? 0;
  }

  // Get current game configuration
  async getGameConfig(): Promise<GameConfig> {
    const { gameConfig } = this.getPDAs();
    const account = await this.program.account.gameConfig.fetch(gameConfig);

    // Add null checks for account fields
    if (!account) {
      throw new Error("Failed to fetch game config account");
    }

    return {
      authority: account.authority?.toBase58() ?? "", // Convert PublicKey to string
      treasury: account.treasury?.toBase58() ?? "", // Convert PublicKey to string
      houseFeeBasisPoints: account.houseFeeBasisPoints ?? 0,
      minBetLamports: account.minBetLamports?.toNumber() ?? 0,
      smallGameDurationConfig: {
        waitingPhaseDuration: account.smallGameDurationConfig?.waitingPhaseDuration?.toNumber() ?? 0,
      },
      betsLocked: account.betsLocked ?? false,
    };
  }

  // Get current game round state (simplified for small games MVP)
  async getGameRound(): Promise<GameRound | null> {
    // First get the current round ID
    const currentRoundId = await this.getCurrentRoundId();

    // Derive the PDA for the current round
    const { gameRound } = this.getPDAs(currentRoundId);

    if (!gameRound) {
      throw new Error("Failed to derive game round PDA");
    }

    try {
      const account = await this.program.account.gameRound.fetch(gameRound);

      // Add null checks for account fields
      if (!account) {
        throw new Error("Failed to fetch game round account");
      }

      // Convert status from Anchor enum to our enum (simplified for small games MVP)
      let status: GameStatus;
      if (account.status?.idle) status = GameStatus.Idle;
      else if (account.status?.waiting) status = GameStatus.Waiting;
      else if (account.status?.awaitingWinnerRandomness) status = GameStatus.AwaitingWinnerRandomness;
      else if (account.status?.finished) status = GameStatus.Finished;
      else throw new Error("Unknown game status");

      console.log("Fetched game round account:", account);

      return {
        roundId: account.roundId?.toNumber() ?? 0,
        status,
        startTimestamp: account.startTimestamp?.toNumber() ?? 0,
        endTimestamp: account.endTimestamp?.toNumber() ?? 0,
        bets: (account.bets || []).map((p: any) => ({
          wallet: p.wallet?.toBase58() ?? "", // Convert PublicKey to string
          betAmount: p.betAmount?.toNumber() ?? 0,
          timestamp: p.timestamp?.toNumber() ?? 0,
        })),
        totalPot: account.totalPot?.toNumber() ?? 0,
        winner: account.winner ? account.winner.toBase58() : null, // Convert PublicKey to string or null
        // ORAO VRF integration
        vrfRequestPubkey: account.vrfRequestPubkey ? account.vrfRequestPubkey.toBase58() : null, // Convert PublicKey to string or null
        vrfSeed: Array.from(account.vrfSeed),
        randomnessFulfilled: account.randomnessFulfilled,
      };
    } catch (error) {
      // Game round account doesn't exist yet (no bets placed)
      console.log("No game round exists yet for round", currentRoundId);
      return null;
    }
  }

  // Get current Solana slot
  async getCurrentSlot(): Promise<number> {
    return await this.connection.getSlot("confirmed");
  }

  // Close betting window and lock game for resolution
  async closeBettingWindow(): Promise<string> {
    // Get current round ID to derive correct game PDA
    const currentRoundId = await this.getCurrentRoundId();
    const { gameConfig, gameCounter, gameRound } = this.getPDAs(currentRoundId);

    if (!gameRound) {
      throw new Error("Failed to derive game round PDA");
    }

    const tx = await this.program.methods
      .closeBettingWindow()
      .accounts({
        counter: gameCounter,
        gameRound: gameRound,
        config: gameConfig,
        crank: this.authority.publicKey,
      } as any) // Temporary until TypeScript types are properly generated
      .rpc();

    return tx;
  }

  // Select winner using VRF and distribute payouts
  async selectWinnerAndPayout(vrfRequestPubkeyStr: string): Promise<string> {
    const vrfRequestPubkey = new PublicKey(vrfRequestPubkeyStr);

    // Get current round ID to derive correct game PDA
    const currentRoundId = await this.getCurrentRoundId();
    const { gameConfig, gameCounter, gameRound, vault } = this.getPDAs(currentRoundId);

    if (!gameRound) {
      throw new Error("Failed to derive game round PDA");
    }

    // Fetch current game round to get player accounts
    const gameRoundAccount = await this.program.account.gameRound.fetch(gameRound);

    // Get treasury from game config
    const gameConfigAccount = await this.program.account.gameConfig.fetch(gameConfig);

    // Prepare remaining accounts - all player accounts that could potentially win
    const remainingAccounts = (gameRoundAccount.bets || []).map((bet: any) => ({
      pubkey: bet.wallet,
      isWritable: true, // Player accounts will receive funds if they win
      isSigner: false, // Player accounts are not signing this transaction
    }));

    const tx = await this.program.methods
      .selectWinnerAndPayout()
      .accounts({
        counter: gameCounter,
        gameRound: gameRound,
        config: gameConfig,
        vault,
        crank: this.authority.publicKey,
        vrfRequest: vrfRequestPubkey,
        treasury: gameConfigAccount.treasury,
        systemProgram: anchor.web3.SystemProgram.programId,
      } as any) // Temporary until TypeScript types are properly generated
      .remainingAccounts(remainingAccounts)
      .rpc();

    return tx;
  }

  // Check if ORAO VRF is fulfilled
  async checkVrfFulfillment(vrfRequestPubkeyStr: string | null): Promise<boolean> {
    if (!vrfRequestPubkeyStr) {
      return false; // No VRF request yet
    }

    try {
      const vrfRequestPubkey = new PublicKey(vrfRequestPubkeyStr);
      const vrfAccount = await this.connection.getAccountInfo(vrfRequestPubkey);
      if (!vrfAccount || vrfAccount.data.length < 49) {
        return false;
      }

      // Check fulfillment flag at offset 48
      return vrfAccount.data[48] !== 0;
    } catch (error) {
      console.error("Error checking VRF fulfillment:", error);
      return false;
    }
  }

  // Note: VRF helper methods removed - VRF is now handled directly by the smart contract
  // via ORAO VRF integration in create_game instruction

  // Confirm transaction with retry logic
  async confirmTransaction(signature: string, maxRetries: number = 3): Promise<boolean> {
    let retries = 0;

    while (retries < maxRetries) {
      try {
        const result = await this.connection.confirmTransaction(signature, "confirmed");

        if (result.value.err) {
          console.error(`Transaction failed: ${signature}`, result.value.err);
          return false;
        }

        return true;
      } catch (error) {
        retries++;
        console.warn(
          `Transaction confirmation retry ${retries}/${maxRetries} for ${signature}:`,
          error
        );

        if (retries >= maxRetries) {
          console.error(
            `Transaction confirmation failed after ${maxRetries} retries: ${signature}`
          );
          return false;
        }

        // Wait before retry
        await new Promise((resolve) => setTimeout(resolve, 2000));
      }
    }

    return false;
  }

  // Health check - test connection and authority
  async healthCheck(): Promise<{ healthy: boolean; message: string; slot?: number }> {
    try {
      // Test connection
      const slot = await this.getCurrentSlot();

      // Test authority balance
      const balance = await this.connection.getBalance(this.authority.publicKey);
      if (balance < 10_000_000) {
        // Less than 0.01 SOL
        return {
          healthy: false,
          message: `Authority balance too low: ${balance / 1e9} SOL`,
          slot,
        };
      }

      // Test if game accounts exist
      const { gameConfig, gameCounter } = this.getPDAs();
      await this.program.account.gameConfig.fetch(gameConfig);
      await this.program.account.gameCounter.fetch(gameCounter);

      // Note: We don't check gameRound here since it may not exist yet (no bets placed)

      return {
        healthy: true,
        message: "All systems healthy",
        slot,
      };
    } catch (error) {
      return {
        healthy: false,
        message: `Health check failed: ${error instanceof Error ? error.message : String(error)}`,
      };
    }
  }
}
