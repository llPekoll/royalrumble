// Solana integration layer for the Convex crank service
import * as anchor from "@coral-xyz/anchor";
import { Connection, PublicKey, Keypair, Transaction, sendAndConfirmTransaction } from "@solana/web3.js";
import { 
  GameConfig, 
  GameRound, 
  GameStatus, 
  DOMIN8_PROGRAM_ID, 
  PDA_SEEDS,
  TRANSACTION_TYPES,
  INSTRUCTION_NAMES 
} from "./types";

// Import the IDL type (this will be generated by Anchor)
import type { Domin8Prgm } from "../../target/types/domin8_prgm";

export class SolanaClient {
  private connection: Connection;
  private program: anchor.Program<Domin8Prgm>;
  private provider: anchor.AnchorProvider;
  private authority: Keypair;

  constructor(
    rpcEndpoint: string,
    authorityPrivateKey: string
  ) {
    // Initialize connection
    this.connection = new Connection(rpcEndpoint, "confirmed");
    
    // Create authority keypair from private key
    const privateKeyBytes = JSON.parse(authorityPrivateKey);
    this.authority = Keypair.fromSecretKey(new Uint8Array(privateKeyBytes));
    
    // Create provider
    this.provider = new anchor.AnchorProvider(
      this.connection,
      new anchor.Wallet(this.authority),
      { commitment: "confirmed" }
    );
    
    // Initialize program (IDL will be fetched automatically)
    this.program = new anchor.Program<Domin8Prgm>(
      {} as any, // IDL placeholder
      DOMIN8_PROGRAM_ID,
      this.provider
    );
  }

  // Get PDAs for the game accounts
  private getPDAs() {
    const [gameConfig] = PublicKey.findProgramAddressSync(
      [PDA_SEEDS.GAME_CONFIG],
      DOMIN8_PROGRAM_ID
    );
    
    const [gameRound] = PublicKey.findProgramAddressSync(
      [PDA_SEEDS.GAME_ROUND],
      DOMIN8_PROGRAM_ID
    );
    
    const [vault] = PublicKey.findProgramAddressSync(
      [PDA_SEEDS.VAULT],
      DOMIN8_PROGRAM_ID
    );

    return { gameConfig, gameRound, vault };
  }

  // Get current game configuration
  async getGameConfig(): Promise<GameConfig> {
    const { gameConfig } = this.getPDAs();
    const account = await this.program.account.gameConfig.fetch(gameConfig);
    
    return {
      authority: account.authority,
      treasury: account.treasury,
      houseFeeBasisPoints: account.houseFeeBasisPoints,
      minBetLamports: account.minBetLamports.toNumber(),
      smallGameDurationConfig: {
        waitingPhaseDuration: account.smallGameDurationConfig.waitingPhaseDuration.toNumber(),
        // eliminationPhaseDuration - not used in small games MVP
        // spectatorBettingDuration - removed for small games MVP
        resolvingPhaseDuration: account.smallGameDurationConfig.resolvingPhaseDuration.toNumber(),
      },
      // largeGameDurationConfig - removed for small games MVP
    };
  }

  // Get current game round state (simplified for small games MVP)
  async getGameRound(): Promise<GameRound> {
    const { gameRound } = this.getPDAs();
    const account = await this.program.account.gameRound.fetch(gameRound);
    
    // Convert status from Anchor enum to our enum (simplified for small games MVP)
    let status: GameStatus;
    if (account.status.idle) status = GameStatus.Idle;
    else if (account.status.waiting) status = GameStatus.Waiting;
    // Large game statuses removed for small games MVP:
    // else if (account.status.awaitingFinalistRandomness) status = GameStatus.AwaitingFinalistRandomness;
    // else if (account.status.spectatorBetting) status = GameStatus.SpectatorBetting;
    else if (account.status.awaitingWinnerRandomness) status = GameStatus.AwaitingWinnerRandomness;
    else if (account.status.finished) status = GameStatus.Finished;
    else throw new Error("Unknown game status");

    return {
      roundId: account.roundId.toNumber(),
      status,
      startTimestamp: account.startTimestamp.toNumber(),
      players: account.players.map(p => ({
        wallet: p.wallet,
        totalBet: p.totalBet.toNumber(),
        timestamp: p.timestamp.toNumber(),
      })),
      // Large game fields removed for small games MVP:
      // finalists: account.finalists,
      // spectatorBets: account.spectatorBets.map(...),
      // spectatorPot: account.spectatorPot.toNumber(),
      // finalistRandomnessAccount: account.finalistRandomnessAccount,
      initialPot: account.initialPot.toNumber(),
      winner: account.winner,
      winnerRandomnessAccount: account.winnerRandomnessAccount,
      randomnessCommitSlot: account.randomnessCommitSlot.toNumber(),
    };
  }

  // Get current Solana slot
  async getCurrentSlot(): Promise<number> {
    return await this.connection.getSlot("confirmed");
  }

  // Progress game to resolution phase
  async progressToResolution(): Promise<string> {
    const { gameRound } = this.getPDAs();
    
    const tx = await this.program.methods
      .progressToResolution()
      .accounts({
        gameRound,
        crank: this.authority.publicKey,
      })
      .rpc();
      
    return tx;
  }

  // Resolve finalists using VRF - REMOVED FOR SMALL GAMES MVP
  // async resolveFinalists(randomnessAccount: PublicKey): Promise<string> {
  //   const { gameRound } = this.getPDAs();
  //   
  //   const tx = await this.program.methods
  //     .resolveFinalists()
  //     .accounts({
  //       gameRound,
  //       randomnessAccount,
  //       crank: this.authority.publicKey,
  //     })
  //     .rpc();
  //     
  //   return tx;
  // }

  // Progress to final battle phase - REMOVED FOR SMALL GAMES MVP
  // async progressToFinalBattle(): Promise<string> {
  //   const { gameRound } = this.getPDAs();
  //   
  //   const tx = await this.program.methods
  //     .progressToFinalBattle()
  //     .accounts({
  //       gameRound,
  //       crank: this.authority.publicKey,
  //     })
  //     .rpc();
  //     
  //   return tx;
  // }

  // Resolve winner using VRF
  async resolveWinner(randomnessAccount: PublicKey): Promise<string> {
    const { gameRound } = this.getPDAs();
    
    const tx = await this.program.methods
      .resolveWinner()
      .accounts({
        gameRound,
        randomnessAccount,
        crank: this.authority.publicKey,
      })
      .rpc();
      
    return tx;
  }

  // Distribute winnings and reset game
  async distributeWinningsAndReset(winner: PublicKey): Promise<string> {
    const { gameConfig, gameRound, vault } = this.getPDAs();
    
    // Get the winnings claim PDA for this round
    const gameRoundAccount = await this.program.account.gameRound.fetch(gameRound);
    const roundId = gameRoundAccount.roundId;
    
    const [winningsClaim] = PublicKey.findProgramAddressSync(
      [Buffer.from("winnings"), roundId.toArrayLike(Buffer, "le", 8)],
      DOMIN8_PROGRAM_ID
    );
    
    // Get treasury from game config
    const gameConfigAccount = await this.program.account.gameConfig.fetch(gameConfig);
    
    const tx = await this.program.methods
      .distributeWinningsAndReset()
      .accounts({
        gameConfig,
        gameRound,
        winningsClaim,
        vault,
        treasury: gameConfigAccount.treasury,
        winner: winner,
        crank: this.authority.publicKey,
        systemProgram: anchor.web3.SystemProgram.programId,
      })
      .rpc();
      
    return tx;
  }

  // Confirm transaction with retry logic
  async confirmTransaction(
    signature: string, 
    maxRetries: number = 3,
    timeoutMs: number = 30000
  ): Promise<boolean> {
    let retries = 0;
    
    while (retries < maxRetries) {
      try {
        const result = await this.connection.confirmTransaction(
          signature,
          "confirmed"
        );
        
        if (result.value.err) {
          console.error(`Transaction failed: ${signature}`, result.value.err);
          return false;
        }
        
        return true;
      } catch (error) {
        retries++;
        console.warn(`Transaction confirmation retry ${retries}/${maxRetries} for ${signature}:`, error);
        
        if (retries >= maxRetries) {
          console.error(`Transaction confirmation failed after ${maxRetries} retries: ${signature}`);
          return false;
        }
        
        // Wait before retry
        await new Promise(resolve => setTimeout(resolve, 2000));
      }
    }
    
    return false;
  }

  // Health check - test connection and authority
  async healthCheck(): Promise<{ healthy: boolean; message: string; slot?: number }> {
    try {
      // Test connection
      const slot = await this.getCurrentSlot();
      
      // Test authority balance
      const balance = await this.connection.getBalance(this.authority.publicKey);
      if (balance < 10_000_000) { // Less than 0.01 SOL
        return {
          healthy: false,
          message: `Authority balance too low: ${balance / 1e9} SOL`,
          slot
        };
      }
      
      // Test if game accounts exist
      const { gameConfig, gameRound } = this.getPDAs();
      await this.program.account.gameConfig.fetch(gameConfig);
      await this.program.account.gameRound.fetch(gameRound);
      
      return {
        healthy: true,
        message: "All systems healthy",
        slot
      };
    } catch (error) {
      return {
        healthy: false,
        message: `Health check failed: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }
}